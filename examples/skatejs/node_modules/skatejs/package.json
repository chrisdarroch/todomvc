{
  "name": "skatejs",
  "description": "Skate is a web component library based loosely on the Custom Element spec that allows you to define behaviour for custom and existing elements using tag names, attribute names and class names.",
  "version": "0.13.2",
  "author": {
    "name": "Trey Shugart",
    "email": "treshugart@gmail.com",
    "url": "http://treshugart.github.io"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:skatejs/skatejs"
  },
  "main": "lib/skate.js",
  "dependencies": {},
  "devDependencies": {
    "bootstrap": "^3.3.0",
    "chippy": "git+https://github.com/treshugart/chippy#dfc4c5022a103e81eeb0404c8026ddb1ca5fd6da",
    "gulp": "^3.8.11",
    "gulp-auto-task": "0.0.1",
    "shadejs": "git+https://github.com/skatejs/shade#8b903d0a7c6ad884353b277b5f19e3e72e118d82"
  },
  "scripts": {
    "deploy": "gulp deploy",
    "dist": "gulp dist",
    "docs": "gulp docs",
    "lib": "gulp lib",
    "lint": "gulp lint",
    "release": "gulp release",
    "test": "gulp test"
  },
  "gitHead": "438a5013b12cb6414369ee45c695b1dac63a8a31",
  "readme": "[![Build Status](https://travis-ci.org/skatejs/skatejs.png?branch=master)](https://travis-ci.org/skatejs/skatejs)\n\n# Skate\n\nSkate is a web component library that is focused on being a tiny, performant, syntactic-sugar for binding behaviour to custom and existing elements without ever having to worry about when your element is inserted into the DOM. It uses the [Custom Element](http://w3c.github.io/webcomponents/spec/custom/) spec as a guideline and adds some features on top of it.\n\nHTML\n\n```html\n<my-component></my-component>\n```\n\nJavaScript\n\n```js\nskate('my-component', {\n  created: function (element) {\n    element.textContent = 'Hello, World!';\n  }\n});\n```\n\nResult\n\n```html\n<my-component>Hello, World!</my-component>\n```\n\n\n\n## Compatibility\n\nIE9+ and all evergreens.\n\n\n\n## Installing\n\nYou can download the source yourself and put it wherever you want. Additionally you can use Bower:\n\n    bower install skatejs\n\nOr NPM:\n\n    npm install skatejs\n\nInclude either `dist/skate.js` or `dist/skate.min.js`.\n\n\n\n### UMD (AMD / CommonJS)\n\nUMD files are located in `lib/`. Simply import `lib/skate.js` and use it as normal.\n\n\n\n### ES6 Modules\n\nThe Skate source is written using [ES6 modules](http://www.2ality.com/2014/09/es6-modules-final.html). If you're using a transpilation method, then you can `import skate from 'src/skate';` and use it in your projects as you would any ES6 module.\n\n\n\n### Global\n\nIf you're still skating old school the `dist` directory contains the compiled ES5 source. The compiled source does not use a module loader; everything will just work. Access Skate as a global with `skate`.\n\n\n\n## Usage\n\nYou define a component by passing a component ID and definition to the `skate()` function. The ID you specify corresponds to one of the following:\n\n- Tag name\n- Value of the `is` attribute\n- Attribute name\n- Class name\n\nThe definition is an object of options defining your component.\n\n```js\nskate('my-component', {\n  // Called before the element is displayed.\n  created: function (element) {\n\n  },\n\n  // Called after the element is displayed.\n  attached: function (element) {\n\n  },\n\n  // Called after the element is removed.\n  detached: function (element) {\n\n  },\n\n  // Attribute callbacks that get triggered when attributes on the main web\n  // component are inserted, updated or removed. Each callback gets the\n  // element that the change occurred on and the corresponding changes. The\n  // change object contains the following information:\n  //\n  // - type: The type of modification (created, updated or removed).\n  // - name: The attribute name.\n  // - newValue: The new value. If type === 'removed', this will be undefined.\n  // - oldValue: The old value. If type === 'created', this will be undefined.\n  attributes: {\n    'my-attribute': {\n      // The element's default value if not already specified on the element.\n      // Can also be a function that returns a value. The function gets passed\n      // The element as its only argument.\n      value: 'default value',\n\n      // Called when the attribute is set for the first time.\n      created: function (element, change) {\n\n      },\n\n      // Called on all attribute modifications except for the intial creation.\n      updated: function (element, change) {\n\n      },\n\n      // Called when the attribute is removed.\n      removed: function (element, change) {\n\n      },\n\n      // Called when created, updated or remove is not specified. This is the\n      // same as specifying a function instead of an options object for a\n      // given attribute.\n      fallback: function (element, change) {\n\n      }\n    }\n  },\n\n  // The event handlers to bind to the web component element. If the event\n  // name is followed by a space and a CSS selector, the handler is only\n  // triggered if a descendant matching the selector triggered the event.\n  // This is synonymous with Backbone's style of event binding in its\n  // views.\n  events: {\n    'click': function (element, eventObject) {\n\n    },\n\n    'click .some-child-selector': function (element, eventObject, currentTarget) {\n\n    }\n  },\n\n  // Restricts a particular component to binding explicitly to an element with\n  // a tag name that matches the specified value. This value is empty by\n  // default.\n  //\n  // Depending on the component type, it behaves like so:\n  //\n  // - When applied to a custom element, the component ID is used to match the\n  //   value of the element's `is` attribute and the element's tag name is\n  //   matched against the value specified here. This conforms with the custom\n  //   element spec.\n  //\n  // - When given to a component that binds to an element using an attribute,\n  //   the value specified here must match the element's tag name.\n  //\n  // - When specified on a component that is bound using a class name, this\n  //   value must match the element's tag name, as with attribute components.\n  //\n  // - If the value is empty, then the component is not restricted at all.\n  extends: '',\n\n  // Properties and methods to add to each element instance. It's notable\n  // that the element's prototype is not modified. These are added after the\n  // element is instantiated. Since the methods and properties are applied to\n  // the element, `this` inside a method will refer to the element.\n  prototype: {\n    callMeLikeAnyNativeMethod: function () {\n\n    }\n  },  \n\n  // A function that renders a template to your element. You can literally use\n  // any templating engine you like here.\n  template: function (element) {\n    bindLatestHipsterTemplateEngineTo(element);\n  },\n\n  // The binding methods this component supports. For example, if you specify\n  // the `type` as `skate.type.ELEMENT`, then the component will only be bound\n  // to an element whos tag name matches the component ID.\n  //\n  // - `ELEMENT` Tag name only.\n  // - `ATTRIBUTE` Attribute names.\n  // - `CLASSNAME` Class names.\n  type: skate.type.ELEMENT,\n\n  // The attribute name to add after calling the created() callback.\n  resolvedAttribute: 'resolved',\n\n  // The attribute name to remove after calling the created() callback.\n  unresolvedAttribute: 'unresolved'\n});\n\n```\n\n\n\n### Component Lifecycle\n\nThe component lifecycle consists of three callbacks:\n\n1. `created`\n2. `attached`\n3. `detached`\n\nThese callbacks try and mimic the spec as closely as possible when native support is unavailable.\n\n#### `created`\n\nThe `created` callback gets triggered when the element is created. There are some differences when using native vs polyfilled support.\n\n```js\n// native: called immediately (synchronous)\n// polyfill: called immediately (synchronous)\nnew MyEl();\n\n// native: called immediately (synchronous)\n// polyfill: called when inserted to the DOM (asynchronous)\ndocument.createElement('my-el');\n\n// native: called immediately (synchronous)\n// polyfill: called when the mutation observer fires (asynchronous)\ndocument.body.innerHTML = '<my-el></my-el>';\n\n// native: called immediately (synchronous)\n// polyfill: called when <div> is inserted into the DOM (asynchronous)\ndocument.createElement('div').innerHTML = '<my-el></my-el>';\n```\n\nIn instances where an element is initialised asynchronously, there may be a flash of unstyled content or jank. For more information see [Preventing FOUC](#preventing-fouc).\n\nIf using native custom elements, the element may not have any children when the `created` callback is invoked. You should not assume a specific structure exists here unless you've used the `template` callback.\n\n```js\n// Will not have children.\ndocument.createElement('my-el');\n\n// Will have children.\ndocument.body.innerHTML = '<my-el>child</my-el>';\ndocument.createElement('div').innerHTML = '<my-el>child</my-el>';\n```\n\n#### `attached`\n\nThe `attached` callback is fired when the element is attached to the `document`. It must actually be in the document to be triggered. This means if you attach your custom element to an element that is detached from the `document`, it will not be called until the element in which you've attached it to is inserted into the `document`.\n\n#### `detached`\n\nThe `detached` callback is fired when the element is detached from the `document`. Like the `attached` callback, this only gets fired when the element gets removed from the `document`.\n\n\n\n### Element Constructors\n\nAs with the spec, when you define a component that is compatible with tag bindings, your call to `skate()` will return an element constructor for you to use:\n\n```js\nvar MyComponent = skate('my-component', {\n  created: function (element) {\n    element.textContent = 'something';\n  },\n\n  prototype: {\n    logTextContent: function () {\n      console.log(this.textContent);\n    }\n  }\n});\n```\n\nIt is favourable to use a constructor in your code wherever possible because it will synchronously initialise the component and call the `created` callback. Only when you insert it into the DOM will the `attached` callback be called:\n\n```js\nvar element = new MyComponent();\n\n// Logs: \"something\"\nelement.logTextContent();\n\n// Asynchronously calls the `attached` callback.\ndocument.body.appendChild(element);\n```\n\n\n\n### Extending Components\n\nOnce you have an element constructor, you can extend the component that constructor represents. For example, in ES6 you might do this:\n\n```js\nvar MyEl = skate('my-el', {});\nvar MySuperEl = skate('my-super-el', class extends MyEl);\n```\n\n\n\n### Attribute Lifecycle\n\nAn attribute lifecycle definition can take three forms. First, it does something similar to what we see in the Web Component spec:\n\n```js\nskate('my-component', {\n  attributes: function (element, change) {\n\n  }\n});\n```\n\nA notable difference, though, is that this callback gets called for attributes that already exist on the element as this is more predictable. This also allows you to have initialisation code for attributes, rather than forcing the developer to do this in one of the lifecycle callbacks.\n\nThis is called for each attribute on an element when:\n\n- The element is created with attributes already on it.\n- Attributes are added to the element.\n- Attributes on the element are updated.\n- Attributes are removed from the element.\n\nThe second form of a callback takes an object of attribues and handlers.\n\n```js\nskate('my-component', {\n  attributes: {\n    'my-attribute': function handleAnyChange (element, change) {\n\n    }\n  }\n});\n```\n\nThis allows you to specify which attributes you want to listen to and will call the specified function when:\n\n- The element is created with the corresponding attribute already on it.\n- The corresponding attribute is added to the element.\n- The corresponding attribute is updated on the element.\n- The corresponding attribute is removed from the element.\n\nThe third form gives you more granularity and flexibility, and is the same form that the example component at the top takes:\n\n```js\nskate('my-component', {\n  attributes: {\n    'my-attribute': {\n      created: function (element, change) {\n\n      },\n\n      updated: function (element, change) {\n\n      },\n\n      removed: function (element, change) {\n\n      }\n    }\n  }\n});\n```\n\nThe `created` handler gets called when:\n\n- The element is created with the corresponding attribute already on it.\n- The corresponding attribute is added to the element.\n\nThe `updated` handler gets called when:\n\n- The corresponding attribute is updated on the element.\n\nThe `removed` handler gets called when:\n\n- The corresponding attribute is removed from the element.\n\nCallbacks that get fired for attributes that already exist on an element get called after the `attached` callback is triggered.\n\n\n\n#### Catching Unspecified Modifications\n\nYou may also specify a `fallback` callback that will get called if a specific callback for the type of modification isn't found. For example, if you wanted to do the same thing on `created` and `updated` but something different on `removed`, then you'd do something like:\n\n```js\nskate('my-component', {\n  attributes: {\n    'my-attribute': {\n      fallback: function (element, change) {\n\n      },\n\n      removed: function (element, change) {\n\n      }\n    }\n  }\n}\n```\n\nNote that doing:\n\n```js\nskate('my-component', {\n  attributes: {\n    'my-attribute': {\n      fallback: function (element, change) {\n\n      }\n    }\n  }\n}\n```\n\nIs the same thing as:\n\n```js\nskate('my-component', {\n  attributes: {\n    'my-attribute': function (element, change) {\n\n    }\n  }\n}\n```\n\nThe only difference is that the former allows you to specify other options for that specific attribute.\n\n\n#### Default Values\n\nIf you want to specify a default value for your component you may do so by setting the `default` option for an attribute.\n\n```js\nskate('my-component', {\n  attributes: {\n    'my-attribute': {\n      value: 'default value'\n    }\n  }\n}\n```\n\nThat would ensure that the attribute `my-attribute` is set to `default value` but only if that attribute doesn't already exist.\n\n\n\n### Event Binding\n\nEvent binding allows you to declare which events you want to listen for and also offers you the ability to use event delegation, Backbone style.\n\nAs we saw above:\n\n```js\nskate('my-component', {\n  events: {\n    'click': function (element, eventObject) {\n\n    },\n\n    'click .some-child-selector': function (element, eventObject, currentTarget) {\n\n    }\n  }\n});\n```\n\nThe first `click` handler gets executed whenever the component receives a click event regardless of what triggered it. The second `click .some-child-selector` handler gets executed only when it receives a click event that came from a descendant matching the `.some-child-selector` selector, This will also get fired for any ancestor of the target, up to the component element, that matches the selector. The `currentTarget` parameter is the element which the delegate selector matched.\n\nEvents listeners are not automatically removed from the element when it is removed from the DOM. This is because Skate does not know if you intend to re-insert the element back into the DOM. Skate leaves it up to you and the JavaScript engine's garbage collector to manage this.\n\n\n\n### Custom Methods and Properties\n\nSkate gives you the option to specify custom properties and methods on your component.\n\n```js\nskate('my-component', {\n  prototype: {\n    callMeLikeAnyNativeMethod: function () {\n\n    }\n  }\n});\n```\n\nThese members are applied directly to the element instance that your component is bound to so you can do stuff like this:\n\n```js\ndocument.getElementById('my-component-id').callMeLikeanyNativeMethod();\n```\n\nIt's important to understand that the `Element.prototype` is not modified as part of this process.\n\n\n\n### Templating\n\nTo template a component, all you need to do is define a function that takes an element as its first argument. When templating is invoked during an element's lifecycle, this function will be called and the element being Skated will be passed in as the first argument. It's up to you at this point to invoke whatever templating engine you want.\n\nFor example, Handlebars:\n\n```js\nskate('my-component', {\n  template: function (element) {\n    var compiled = Handlebars.compile('<p>Hello, {{ name }}!</p>');\n    element.innerHTML = compiled({ name: element.getAttribute('name') });\n  }\n});\n```\n\nA good way to reuse a template function is to simply create a function that takes a string and returns a function that templates that string. The following example will compile the HTML using Handlebars and when invoked it will take all the attributes on the element and pass them in to the compiled template function as the context. This way, you can use any of the attributes specified on the element.\n\n```js\nfunction handlebarify (html) {\n  var compiled = Handlebars.compile(html);\n\n  return function (element) {\n    var attrs = {};\n\n    for (var a = 0; a < element.attributes.length; a++) {\n      var attr = element.attributes[a];\n      attrs[attr.name] = attr.value;\n    }\n\n    element.innerHTML = compiled(attrs);\n  };\n}\n\nskate('my-component', {\n  template: handlebarify('<p>Hello, {{ name }}!</p>')\n});\n```\n\nIf you wanted to fully embrace Web Components, you could even use Shadow DOM:\n\n```js\nfunction shadowDomTemplate (shadowHtml) {\n  return function (element) {\n    element.createShadowRoot().innerHTML = shadowHtml;\n  };\n}\n\nskate('my-component', {\n  template: shadowDomTemplate('<header><content select=\"h2\"></content></header><section><content></content></section>')\n});\n```\n\n\n\n### Asynchrony\n\nDue to the fact that Skate uses Mutation Observers - and polyfills it for older browsers - elements are processed asynchronously. This means that if you insert an element into the DOM, custom methods and properties on that element will not be available right away. This will not work:\n\n```js\ndocument.body.innerHTML = '<my-component id=\"my-component-id\"></my-component>';\n\ndocument.getElementById('my-component-id').someCustomMethod();\n```\n\nThis is because the component will not be processed until after the block this code is in releases control back to the JavaScript engine. If you need to use the element right away, you must explicitly initialise it in a synchronous manner using `skate.init()`:\n\n```js\nvar element = document.getElementById('my-component-id');\n\nskate.init(element);\n\nelement.someCustomMethod();\n```\n\nThis is very useful during testing, but can be used for any use case that requires synchronous operation.\n\n\n\n## Web Component Differences\n\nSkate uses the [Custom Element spec](http://w3c.github.io/webcomponents/spec/custom/) as a guideline but it does not polyfill it, nor does it polyfill the behaviour of [ShadowDOM](http://w3c.github.io/webcomponents/spec/shadow/) or [HTML Imports](http://w3c.github.io/webcomponents/spec/imports/).\n\nYou can do some pretty cool things with Skate that you can't do with Web Components. For example, you can write polyfills for existing elements:\n\n`<datalist>...</datalist>`:\n\n```js\nskate('datalist', {\n  created: polyfillDatalistElement\n});\n```\n\n`<input placeholder=\"\">`:\n\n```js\nskate('placeholder', {\n  extends: 'input',\n  type: skate.type.ATTRIBUTE,\n  created: polyfillInputPlaceholder\n});\n```\n\n`<input type=\"date\">`:\n\n```js\nskate('type', {\n  extends: 'input',\n  type: skate.type.ATTRIBUTE,\n  attributes: {\n    type: function (element, change) {\n      if (change.newValue === 'date') {\n        makeIntoDatepicker(element);\n      }\n    }\n  }\n});\n```\n\n`<link rel=\"import\" href=\"path/to/import.html\">` (HTML Imports):\n\n```js\nskate('rel', {\n  extends: 'link',\n  type: skate.type.ATTRIBUTE,\n  attributes: {\n    rel: function (element, change) {\n      if (change.newValue === 'import') {\n        makeIntoHtmlImport(element);\n      }\n    }\n  }\n});\n```\n\n\n\n## Transitioning Away from jQuery-style Plugins\n\nBecause Skate can also bind to attributes and classes, it offers a way to transition away from jQuery-style plugins to web components.\n\n```js\njQuery(function ($) {\n  $('.tabs').tabs();\n});\n```\n\nThere's several problems with this approach. First, you're running a selector against the document. This is unnecessary and can get slow in large DOMs even in the latest browsers. Second, it only gets executed on DOMReady. If you want to dynamically add some tabs to your document, then you've got to manually call that again once they've been added to the DOM.\n\nWith Skate, those problems vanish. No selectors are run and your tabs will automatically be initialised regardless of when they are put into the document.\n\nTo refactor that into a Skate component, all you need to do is:\n\n```js\nskate('tabs', {\n  type: skate.type.CLASSNAME\n  created: function (element) {\n    jQuery(element).tabs();\n  }\n});\n```\n\nPossibly the best part about this is that you don't need to touch any markup and only a minimal amount of JavaScript.\n\n\n\n## Native Support\n\nIf your component is bound via custom tags and your browser supports custom elements then Skate will use the native DOM implementation instead of using Mutation Observers which will have added performance benefits. This all happens underneath the hood and the API does not change.\n\n\n\n## Polyfills\n\nAs you may know, the only way to polyfill Mutation Observers is to use the deprecated DOM 3 Mutation Events. They were deprecated because if you insert 5k elements at once, you then trigger 5k handlers at once. Mutation Observers will batch that into a single callback.\n\nSkate mostly polyfills [Mutation Observers](https://developer.mozilla.org/en/docs/Web/API/MutationObserver), but only internally. It is not usable outside of Skate since it only polyfills what Skate needs to function. Its code is written to withstand an extreme number of incoming DOM elements. It's fast in Internet Explorer, not just modern browsers, and this is what sets it apart from other polyfills. It also ensures that mutation events are queued, rather than executed as they come in. Once queued, they are batched into a single callback.\n\n\n\n## Preventing FOUC\n\nAn element may not be initialised right away. To prevent FOUC, you can add the `unresolved` attribute to any web component element and then use that attribute to hide the element in your stylesheets.\n\n```html\n<style>\n  [unresolved] {\n    opacity: 0;\n  }\n</style>\n<my-element unresolved></my-element>\n```\n\nThe `unresolved` attribute will be removed after the `created()` callback is called and before the `attached()` callback is called.\n\nAdditionally, after removing the `unresolved` attribute, Skate will add the `resolved` attribute. This allows you to transition your styles:\n\n    [resolved] {\n      opacity: 1;\n      transition: opacity .3s ease;\n    }\n\n\n\n## Ignoring Elements\n\nIf you have a DOM tree that you don't want Skate to polyfill then you can add the `data-skate-ignore` attribute. This is ideal for mitigating performance issues associated with older browsers and inspecting each element that is added to the document. Generally this is only an issue in Internet Explorer and dealing with hundreds of thousands of elements. If your browser natively supports Custom Elements then this attribute is ignored.\n\n```html\n<div data-skate-ignore>\n  <!-- Everything including the container will be ignored. -->\n</div>\n```\n\n\n\n## No Conflict\n\nSkate has a `noConflict()` method that we have come to expect from libraries that may come into conflict with the same name, or multiple versions of itself. It returns the new `skate` while restoring the global `skate` to the previous value.\n\n```js\nvar mySkate = skate.noConflict();\n```\n\n\n\n## Multiple Version Support\n\nOn top of offering a no-conflict mode, Skate plays well with multiple versions of itself on the same page. Prior to version `0.11` Skate did not share a registry or mutation observers. `0.11` and later share a registry and a mutation observer. This means that trying to register the same component in `0.11` and `0.12` would result in an error. Sharing a mutation observer ensures that we don't have more than main mutation observer on the page scanning incoming elements which helps with performance.\n\n\n\n## Contributing\n\nThe `.editorconfig`, `.jscs` and `.jshint` configs are all set up. If you can, enable these in your editor of choice.\n\n\n\n### Setup\n\nTo get a dev environment up and running, all you should need to do is run:\n\n```bash\nnpm install\n```\n\n\n### Testing\n\nTo run tests:\n\n```bash\nnpm test\n```\n\nIf you want to keep the Karma server alive to run them in your browser of choice:\n\n```bash\nnpm test -- --watch\n```\n\nTo run tests in a specific browser:\n\n```bash\nnpm test -- --browsers Chrome,Firefox\n```\n\n\n\n### Linting\n\nTo lint your files with `jscs` and `jshint`:\n\n```bash\nnpm run lint\n```\n\n\n\n### Distribution\n\nTo build the distribution all you have to do is run:\n\n```bash\nnpm run dist\n```\n\nThis will build `dist/skate.js` and `dist/skate.min.js`. Don't worry about doing this in a PR; it'll avoid conflicts.\n\nTo build the `lib` (ES5 + UMD) files:\n\n```bash\nnpm run lib\n```\n\n\n\n### Releasing\n\nTo release all you've got to do is run `npm release`. You can either specify the release `type`, or `tag`.\n\n```bash\nnpm run release -- --tag x.x.x\n```\n\nOr:\n\n```bash\nnpm run release -- --type minor\n```\n\n\n\n### Deploying\n\nTo deploy the documentation, run the following command from the branch or tag which you want to deploy:\n\n```bash\nnpm run deploy\n```\n\n\n\n## Who's Using It?\n\n<img alt=\"Atlassian\" src=\"http://www.atlassian.com/dms/wac/images/press/Atlassian-logos/logoAtlassianPNG.png\" width=\"200\">\n\n\n\n## Maintainers\n\n- [Trey Shugart](https://twitter.com/treshugart) (author), Atlassian\n\n\n\n## License\n\nThe MIT License (MIT)\n\nCopyright (c) 2014 Trey Shugart\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/skatejs/skatejs/issues"
  },
  "homepage": "https://github.com/skatejs/skatejs",
  "_id": "skatejs@0.13.2",
  "_shasum": "c0a2dfe6e1b2d0b76b5a0299b28a4ccecdb825f5",
  "_from": "../../../../../../../var/folders/d6/ryk7qgv11x50ympmc18r4q2r0000gp/T/npm-10145-fa5ad451/git-cache-3d4ee90e1cbe/438a5013b12cb6414369ee45c695b1dac63a8a31",
  "_resolved": "git+https://github.com/skatejs/skatejs#438a5013b12cb6414369ee45c695b1dac63a8a31"
}
