{
  "name": "skatejs",
  "description": "Skate is a web component library based loosely on the Custom Element spec that allows you to define behaviour for custom and existing elements using tag names, attribute names and class names.",
  "version": "0.13.2",
  "author": {
    "name": "Trey Shugart",
    "email": "treshugart@gmail.com",
    "url": "http://treshugart.github.io"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/skatejs/skatejs.git"
  },
  "main": "lib/skate.js",
  "dependencies": {},
  "devDependencies": {
    "benchmark": "^1.0.0",
    "bootstrap": "^3.3.0",
    "chippy": "github:treshugart/chippy#dfc4c5022a103e81eeb0404c8026ddb1ca5fd6da",
    "font-awesome": "^4.3.0",
    "gulp": "^3.8.11",
    "gulp-auto-task": "0.0.1",
    "highlight.js": "^8.6.0",
    "shadejs": "github:skatejs/shade#c68961928939c728bf830eea7dbce884dc637695",
    "skatejs-polyfill-mutation-observer": "github:skatejs/polyfill-mutation-observer#a7dbecfe23ee18efc97dac8fbcbb728deeb65a06",
    "skatejs-type-attribute": "github:skatejs/type-attribute#05018faacf590feab5bb6bfa1cafee590b94f315",
    "skatejs-type-class": "github:skatejs/type-class#6e4dd9b6106e34fde4f528fb8ac50ca6eda87855",
    "whatwg-fetch": "^0.9.0"
  },
  "scripts": {
    "deploy": "gulp deploy",
    "dist": "gulp dist",
    "docs": "gulp docs",
    "lib": "gulp lib",
    "lint": "gulp lint",
    "release": "gulp release",
    "test": "gulp test"
  },
  "gitHead": "a3249962713cf2dfb0001467b2d38d9c8a44c94c",
  "readme": "[![Build Status](https://travis-ci.org/skatejs/skatejs.png?branch=master)](https://travis-ci.org/skatejs/skatejs)\n\n*This is the README for the master branch and is probably out of sync with the last stable release. To see the README for the last stable release select it from the list of tags.*\n\n# Skate\n\nSkate is a web component library based on the custom element spec. It's focused on being a tiny, performant, syntactic-sugar for binding behaviour to elements, attributes and classes using a consistent, simple and declarative API.\n\nHTML\n\n```html\n<my-element></my-element>\n```\n\nJavaScript\n\n```js\nskate('my-element', {\n  created: function () {\n    this.textContent = 'Hello, World!';\n  }\n});\n```\n\nResult\n\n```html\n<my-element>Hello, World!</my-element>\n```\n\n\n\n## Documentation\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n\n- [Compatibility](#compatibility)\n- [Installing](#installing)\n  - [UMD (AMD / CommonJS)](#umd-amd--commonjs)\n  - [ES6 Modules](#es6-modules)\n  - [Global](#global)\n- [Usage](#usage)\n- [Component Lifecycle](#component-lifecycle)\n  - [`created`](#created)\n  - [`attached`](#attached)\n  - [`detached`](#detached)\n  - [`attribute`](#attribute)\n  - [`template`](#template)\n- [Event Binding](#event-binding)\n- [Constructing Elements](#constructing-elements)\n  - [Function Call](#function-call)\n  - [`skate.create()`](#skatecreate)\n  - [Constructor](#constructor)\n  - [Hydrating Properties](#hydrating-properties)\n- [Extending Elements](#extending-elements)\n- [Custom Methods and Properties](#custom-methods-and-properties)\n- [Asynchrony](#asynchrony)\n- [API](#api)\n  - [`chain (...args)`](#chain-args)\n  - [`create (name, props = {})`](#create-name-props--)\n  - [`emit (eventName, eventOptions = {})`](#emit-eventname-eventoptions--)\n  - [`event ()`](#event-)\n  - [`init ()`](#init-)\n  - [`noConflict ()`](#noconflict-)\n  - [`property (element, propertyName, propertyDefinition)`](#property-element-propertyname-propertydefinition)\n  - [`property (element, propertyDefinitions)`](#property-element-propertydefinitions)\n  - [`ready (callback)`](#ready-callback)\n  - [`type`](#type)\n  - [`version`](#version)\n  - [`watch (element, callback, options = {})`](#watch-element-callback-options--)\n- [Web Component Differences](#web-component-differences)\n- [Transitioning Away from jQuery-style Plugins](#transitioning-away-from-jquery-style-plugins)\n- [Native Support](#native-support)\n- [Polyfills](#polyfills)\n- [Preventing FOUC](#preventing-fouc)\n- [Ignoring Elements](#ignoring-elements)\n- [No Conflict](#no-conflict)\n- [Multiple Version Support](#multiple-version-support)\n- [Contributing](#contributing)\n  - [Setup](#setup)\n  - [Testing](#testing)\n  - [Linting](#linting)\n  - [Distribution](#distribution)\n  - [Releasing](#releasing)\n  - [Deploying](#deploying)\n- [Who's Using It?](#whos-using-it)\n- [Maintainers](#maintainers)\n- [License](#license)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n\n\n## Compatibility\n\nIE9+ and all evergreens.\n\n\n\n## Installing\n\nYou can download the source yourself and put it wherever you want. Additionally you can use Bower:\n\n    bower install skatejs\n\nOr NPM:\n\n    npm install skatejs\n\nOr JSPM:\n\n    jspm install npm:skatejs\n\nInclude either `dist/skate.js` or `dist/skate.min.js`.\n\n\n\n### UMD (AMD / CommonJS)\n\nUMD files are located in `lib/`. Simply `require` the `lib/index.js` file by whatever means you have and use it in accordance with whatever loader you've chosen.\n\n\n\n### ES6 Modules\n\nThe Skate source is written using [ES6 modules](http://www.2ality.com/2014/09/es6-modules-final.html). If you're using a transpilation method, then you can `import skate from 'src/index';` and use it in your projects as you would any ES6 module.\n\n\n\n### Global\n\nIf you're still skating old school the `dist` directory contains the compiled ES5 source. The compiled source does not use a module loader; everything will just work. Access Skate as a global with `skate`.\n\n\n\n## Usage\n\nYou define a component by passing a component ID and definition to the `skate()` function. The ID you specify corresponds to one of the following:\n\n- Tag name\n- Value of the `is` attribute\n- Attribute name\n- Class name\n\nThe definition is an object of options that define your component.\n\n```js\nskate('my-element', {\n  // Lifecycle Callbacks\n  //\n  // All lifecycle callbacks use `this` to refer to the component element.\n\n  // Called when the element is created.\n  created () {},\n\n  // Called when the element is attached to the document.\n  attached () {},\n\n  // Called when the element is detached from the document.\n  detached () {},\n\n  // Called when an attribute is created, updated or removed.\n  attribute (name, oldValue, newValue) {\n    if (oldValue === null) {\n      // created\n    } else if (newValue === null) {\n      // removed\n    } else {\n      // updated\n    }\n  },\n\n  // A function that renders a template to your element. Since this function is\n  // responsible for rendering the template, you can literally use anything you\n  // want here.\n  template () {\n    this.innerHTML = 'something';\n  },\n\n\n\n  // Event Listeners\n  events: {\n    // All direct and bubbled events.\n    click (e) {\n      // Refers to the component element.\n      this;\n\n      // Standard DOM event object.\n      e;\n\n      // Same as `this`.\n      e.delegateTarget;\n    },\n\n    // Restricted to events triggered only on the component element. Arguments\n    // are the same as above.\n    'click my-element' (e) {},\n\n    // Event delegation.\n    'click .something' (e) {\n      // Same as above.\n      this && e;\n\n      // Instead matches whatever `.something` is.\n      e.delegateTarget;\n    },\n\n    // Multiple handlers.\n    click: [\n      handler1,\n      handler2\n    ],\n\n    // Focus and blur can be delegated, too.\n    'focus .something' () {},\n    'blur .something' () {}\n  },\n\n\n\n  // Extending Elements\n  //\n  // Restricts a particular component to binding explicitly to an element with\n  // a tag name that matches the specified value. This value is empty by\n  // default.\n  //\n  // Depending on the component type, it behaves like so:\n  //\n  // - When applied to a custom element, the component ID is used to match the\n  //   value of the element's `is` attribute and the element's tag name is\n  //   matched against the value specified here. This conforms with the custom\n  //   element spec.\n  //\n  // - When given to a component that binds to an element using an attribute,\n  //   the value specified here must match the element's tag name.\n  //\n  // - When specified on a component that is bound using a class name, this\n  //   value must match the element's tag name.\n  //\n  // - If the value is empty, then the component is not restricted at all.\n  extends: '',\n\n\n\n  // Custom Property Descriptors\n  properties: {\n    prop1: {\n      // Two-way binding to attributes. Changes to this property propagate to\n      // its corresponding attribute and changes to its corresponding attribute\n      // are propagated to the property.\n      //\n      // This defaults to `false`. If you specify `true` the property name is\n      // dash-cased and used as the attribute it should keep in sync with. If\n      // you specify a `string`, it is used as the attribute name.\n      attr: false,\n\n      // This property should be notified of changes when these dependencies\n      // are notified of changes.\n      //\n      // You may also specify dependencies as space-separated string.\n      deps: [\n        // This property's notify events will be triggered when its sibling\n        // `dependencyProperty` is notified of changes.\n        'dependencyProperty',\n\n        // This property's notify events will be triggered when the descendant's\n        // `deepDependencyProperty` notify events are triggered.\n        //\n        // At the time the dependency event bubbles up from the descendant, it\n        // must be accessible via `this.some.nested.child`. If it is not, then\n        // the dependency is ignored.\n        'some.nested.child.deepDependencyProperty'\n      ],\n\n      // Custom getter. The return value is used as the property value when\n      // retrieved. If you don't specify a getter, the value that it was set as\n      // is returned regardless of if you've specified a setter.\n      //\n      // To make a property \"readonly\", specify a getter without a setter.\n      get () {},\n\n      // Whether or not to trigger events when the property changes. Defaults to\n      // `true`. If you do not want events triggered, set this to a falsy value.\n      //\n      // If this is truthy, when the property is changed it will trigger an\n      // event called `skate.property` if `notify` is `true`, or an event with\n      // the same name as `notify` if specified as a `String`.\n      //\n      // The event object for both events contains the following information\n      // in the `detail` property:\n      //\n      // - `name` - The property name.\n      // - `newValue` - The property's new value.\n      // - `oldValue` - The property's old value.\n      notify: true\n\n      // Custom setter. Set value as you see fit. Return value is ignored. If\n      // you don't specify a getter, then whatever `newValue` was passed in to\n      // the setter, is returned by the default getter. If you want to return\n      // a custom value, specify a getter.\n      set (newValue, oldValue) {},\n\n      // A function that coerces the value to another value. You can specify\n      // any function you want here. The return value is then stored internally\n      // and passed as `newValue` in the setter.\n      type: Boolean,\n\n      // This will be used as the initial value for the property. If you specify\n      // a function then it will be invoked and the return value will be used.\n      value: 'initial value'\n    }\n  },\n\n\n\n  // Custom Methods and Properties\n  //\n  // This behaves just like any prototype object does. All methods and\n  // properties are added to the element's prototype (native), or to the element\n  // instance during the `created` lifecycle (polyfill).\n  //\n  // It's recommended you use the `properties` option for all public-api\n  // properties, but nothing is stopping you from putting them here if you\n  // don't need the special behaviour of `properties`.\n  prototype: {\n    get someProperty () {},\n    someMethod () {}\n  },\n\n\n  // Component Types\n  //\n  // The binding methods this component supports. For example, if you specify\n  // the `type` as `skate.type.ELEMENT`, then the component will only be bound\n  // to an element whos tag name matches the component ID.\n  //\n  // - `ELEMENT` Tag name only.\n  // - `ATTRIBUTE` Attribute names.\n  // - `CLASSNAME` Class names.\n  type: skate.type.ELEMENT,\n\n\n\n  // Preventing FOUC\n  //\n  // The `resolved` and `unresolved` attributes allow you to style a resolved\n  // or unresolved component. You can changes these if you want to use different\n  // names.\n\n  // The attribute name to add after calling the `created` callback.\n  resolvedAttribute: 'resolved',\n\n  // The attribute name to remove after calling the `created` callback.\n  unresolvedAttribute: 'unresolved'\n});\n\n```\n\n\n\n## Component Lifecycle\n\nThe component lifecycle consists several callbacks:\n\n- `created`\n- `attached`\n- `detached`\n- `attribute`\n- `template`\n\n### `created`\n\n```js\nskate('my-element', {\n  created () {}\n});\n```\n\nThe `created` callback gets triggered when the element is created.\n\n#### Timing\n\nThere are some differences when using native vs polyfilled support.\n\n```js\n// native: called immediately (synchronous)\n// polyfill: called immediately (synchronous)\nmyElement();\nnew myElement();\nskate.create('my-element');\n\n// native: called immediately (synchronous)\n// polyfill: called when inserted to the DOM (asynchronous)\ndocument.createElement('my-element');\n\n// native: called immediately (synchronous)\n// polyfill: called when the mutation observer fires (asynchronous)\ndocument.body.innerHTML = '<my-element></my-element>';\n\n// native: called immediately (synchronous)\n// polyfill: called when <div> is inserted into the DOM (asynchronous)\ndocument.createElement('div').innerHTML = '<my-element></my-element>';\n```\n\nIn instances where an element is initialized asynchronously, or your definition is loaded after the element is already on the page, there may be a flash of un-styled content. For more information see [Preventing FOUC](#preventing-fouc).\n\nIf using native custom elements, the element may not have any children when the `created` callback is invoked. You should not assume a specific structure exists. For more information see [skate.ready()](#ready-callback).\n\n```js\n// Will not have children.\ndocument.createElement('my-el');\n\n// Will have children.\ndocument.body.innerHTML = '<my-el>child</my-el>';\ndocument.createElement('div').innerHTML = '<my-el>child</my-el>';\n```\n\n### `attached`\n\n```js\nskate('my-element', {\n  attached () {}\n});\n```\n\nThe `attached` callback is fired when the element is attached to the `document`. It can be invoked more than once. For example, if you were to add and remove the same element multiple times.\n\n#### Timing\n\nThe `attached` callback is called synchronously in native custom elements and asynchronously when polyfilled.\n\n### `detached`\n\n```js\nskate('my-element', {\n  detached () {}\n});\n```\n\nThe `detached` callback is fired when the element is detached from the `document`. It can be invoked more than once. For example, if you were to add and remove the same element multiple times.\n\n#### Timing\n\nThe `detached` callback is called synchronously in native custom elements and asynchronously when polyfilled.\n\n### `attribute`\n\n```js\nskate('my-element', {\n  attribute (name, oldValue, newValue) {\n    if (oldValue === null) {\n      // created\n    } else if (newValue === null) {\n      // removed\n    } else {\n      // updated\n    }\n  }\n});\n```\n\nThe `attribute` callback is fired whenever an element attribute is created, updated or removed. Unlike the native `attributeChangedCallback`, this gets fired for every attribute an element has by the time it is initialised.\n\n#### Timing\n\nAttribute handlers are notified synchronously. Instead of using mutation observers, `setAttribute` and `removeAttribute` are patched to notify the callback as soon as the change occurs. If your existing code uses timeouts to wait until after mutations happen to execute logic related to an attribute change, you don't need to worry about changing it. The only difference is you won't need to write async boilerplate anymore.\n\nHowever, this means that updating the attribute instance directly is *not* supported. If you do the following, the `attribute` callback will *not* be notified of the change. For example the following will not trigger the `attribute` callback:\n\n```js\nmyElement.attributes.myAttribute.value = 'new value';\n```\n\nYou must use the attribute methods instead:\n\n```js\nmyElement.setAttribute('myAttribute', 'new value');\n```\n\n### `template`\n\n```js\nskate('my-element', {\n  template () {}\n});\n```\n\nSince the template function is just a callback and it's up to you how you template the element, you can use any templating engine that you want.\n\n#### Handlebars\n\n```js\nskate('my-element', {\n  template () {\n    var compiled = Handlebars.compile('<p>Hello, {{ name }}!</p>');\n    this.innerHTML = compiled(this);\n  }\n});\n```\n\nA good way to reuse a template function is to simply create a function that takes a string and returns a function that templates that string onto the element. You could rewrite the above example to be reusable very easily:\n\n```js\nfunction handlebarify (html) {\n  var compiled = Handlebars.compile(html);\n  return function () {\n    this.innerHTML = compiled(this);\n  };\n}\n\nskate('my-element', {\n  template: handlebarify('<p>Hello, {{name}}!</p>')\n});\n```\n\n#### Shadow DOM\n\nIf you wanted to fully embrace Web Components, you could even use Shadow DOM:\n\n```js\nfunction shadowify (html) {\n  return function () {\n    this.createShadowRoot().innerHTML = html;\n  };\n}\n\nskate('my-element', {\n  template: shadowify('<p>Hello, <content></content>!</p>')\n});\n```\n\n#### Virtual DOM\n\nYou could also use a virtual DOM implementation - such as [virtual-dom](https://github.com/Matt-Esch/virtual-dom) - here if you wanted to.\n\n```js\nimport createElement from './path/to/virtual-dom/create-element';\n\nfunction createVdomTree (props) {\n  // Return your Virtual DOM tree.\n}\n\nskate('my-element', {\n  template () {\n    var tree = createVdomTree(this);\n    var root = createElement(tree);\n\n    // Initial render.\n    this.appendChild(root);\n  }\n});\n```\n\n#### Responding to Component Changes\n\nIf you want to re-render your component when properties change, you can listen to the `skate.property` event triggered by defined `properties`.\n\nWith Handlebars you might do something like:\n\n```js\nskate('my-element', {\n  template () {\n    var render = handlebarify('<p>Hello, {{name}}!</p>');\n    this.addEventListener('skate.property', render);\n    render.call(this);\n  }\n});\n```\n\nIf you're using Virtual DOM you might do something like:\n\n```js\nimport createElement from './path/to/virtual-dom/create-element';\nimport diff from './path/to/virtual-dom/diff';\nimport patch from './path/to/virtual-dom/patch';\n\nfunction createVdomTree (props) {\n  // Return your Virtual DOM tree.\n}\n\nskate('my-element', {\n  template () {\n    var tree = createVdomTree(this);\n    var root = createElement(tree);\n\n    // Initial render.\n    this.appendChild(root);\n\n    // Subsequent renders.\n    this.addEventListener('skate.property', function () {\n      var newTree = createVdomTree(this);\n      root = patch(root, diff(tree, newTree));\n      tree = newTree;\n    });\n  }\n});\n```\n\n\n\n## Event Binding\n\n```js\nskate('my-element', {\n  events: {\n    // All direct and bubbled events.\n    click (e) {\n      // Refers to the component element.\n      this;\n\n      // Standard DOM event object.\n      e;\n\n      // Same as `this`.\n      e.delegateTarget;\n    },\n\n    // Restricted to events triggered only on the component element. Arguments\n    // are the same as above.\n    'click my-element' (e) {},\n\n    // Event delegation.\n    'click .something' (e) {\n      // Same as above.\n      this && e;\n\n      // Instead matches whatever `.something` is.\n      e.delegateTarget;\n    },\n\n    // Multiple handlers.\n    click: [\n      handler1,\n      handler2\n    ],\n\n    // Focus and blur can be delegated, too.\n    'focus .something' () {},\n    'blur .something' () {}\n  }\n});\n```\n\n\n\n## Constructing Elements\n\nThere's several different ways to construct an element.\n\n### Function Call\n\n```js\nvar myElement = skate('my-element', {});\nvar myElementInstance = myElement();\n```\n\n### `skate.create()`\n\n```js\nskate('my-element', {});\nvar myElementInstance = skate.create('my-element');\n```\n\n### Constructor\n\nWhile not the most elegant way, this serves as an ode to the spec.\n\n```js\nvar MyElement = skate('my-element');\nvar myElementInstance = new MyElement();\n```\n\n### Hydrating Properties\n\nFor each of the ways you can construct an element, Skate also allows you to pass a properties object to them. The properties object is used to hydrate property values for the element.\n\n```js\nvar props = { propname: 'propvalue' };\nvar myElementInstance = myElement(props);\nvar myElementInstance = skate.create('my-element', props);\nvar myElementInstance = new MyElement(props);\n```\n\n\n\n## Extending Elements\n\nYou may extend components using ES6 classes or your favorite ES5 library.\n\n```js\nvar XParent = skate('x-parent', {\n  static created () {\n\n  }\n  static get events {\n    return {\n      event1 () {}\n    }\n  }\n});\n\nvar XChild = skate('x-child', class extends XParent {\n  static created () {\n    super.created();\n  }\n  static get events {\n    return class extends super.events {\n      event1 (e) {\n        super.event1(e);\n      }\n      event2 () {\n\n      }\n    };\n  }\n});\n```\n\nDue to the semantics of ES6 classes, you must specify any non-prototype members as static. ES6 classes also do not support the object literal syntax. In order to specify properties, just use the getter syntax like we did with `events` above.\n\n\n\n## Custom Methods and Properties\n\nSkate gives you the option to specify custom properties and methods on your component.\n\n```js\nskate('my-component', {\n  prototype: {\n    callMeLikeAnyNativeMethod () {}\n  }\n});\n```\n\nThese members are applied directly to the element instance that your component is bound to so you can do stuff like this:\n\n```js\ndocument.getElementById('my-component-id').callMeLikeanyNativeMethod();\n```\n\n\n\n## Asynchrony\n\nDue to the fact that Skate uses Mutation Observers - and polyfills it for older browsers - elements are processed asynchronously. This means that if you insert an element into the DOM, custom methods and properties on that element will not be available right away. This will not work:\n\n```js\ndocument.body.innerHTML = '<my-component id=\"my-component-id\"></my-component>';\n\ndocument.getElementById('my-component-id').someCustomMethod();\n```\n\nThis is because the component will not be processed until after the block this code is in releases control back to the JavaScript engine. If you need to use the element right away, you must explicitly initialise it in a synchronous manner using `skate.init()`:\n\n```js\nvar element = document.getElementById('my-component-id');\n\nskate.init(element);\n\nelement.someCustomMethod();\n```\n\nThis is very useful during testing, but can be used for any use case that requires synchronous operation.\n\n\n\n## API\n\nThe following are all available on the `skate` object, or available for use from the `src/api` or `lib/api` folders.\n\n### `chain (...args)`\n\nReturns a function that attempts to make all arguments passed in callable. The arguments and context passed to the returned function are forwarded, so it can be used to compose behaviour. The context passed to the proxy function is returned.\n\n```js\nfunction increment () {\n  ++this.calls;\n}\n\nvar proxy = skate.chain(\n  // Strings point to a method on the context.\n  'increment',\n\n  // Functions are invoked and passed the context.\n  increment,\n\n  // A new chain is created from array values.\n  [ 'increment', increment ],\n\n  // A new chain is created from object values.\n  { key1: 'increment', key2: increment },\n\n  // Same as both the array and object forms.\n  skate.chain('increment', increment);\n);\n\nvar context = proxy.call({\n  calls: 0,\n  increment: increment\n});\n\n// 8\nconsole.log(context.calls);\n```\n\nThis makes it really simple to compose functionality:\n\n```js\nfunction sharedFunction (e) {}\n\nskate('my-element', {\n  events: {\n    click: skate.chain(\n      'instanceMethod',\n      sharedFunction,\n      function (e) {}\n    )\n  },\n  prototype: {\n    instanceMethod (e) {}\n  }\n});\n```\n\nYou could do all this with in a function, but it's nice not to have to worry about passing context and arguments. Everything is automatically invoked with the same context and arguments:\n\n```js\nfunction sharedFunction (e) {}\n\nskate('my-element', {\n  events: {\n    click: function (e) {\n      this.instanceMethod(e);\n      sharedFunction.call(this, e);\n      (function (e) {}(e));\n    }\n  },\n  prototype: {\n    instanceMethod (e) {}\n  }\n});\n```\n\n\n\n### `create (name, props = {})`\n\nCreates an element for the specified component `name`, ensures that it's synchronously initialized and assigns all `props` to it. On the surface, this doesn't appear much different than `document.createElement()` in browsers that support custom elements, however, there's several benefits that it gives you on top of being a single, consistent and convenient way to do things in any browser and environment.\n\nFor example, this can be called in any browser and it will behave consistently:\n\n```js\nskate.create('my-element');\n```\n\nIn browsers that support custom elements, it is equivalent to:\n\n```js\ndocument.createElement('my-element');\n```\n\nIn browsers that do not support custom elements, you would have to manually ensure that the element is initialised synchronously:\n\n```js\nvar element = document.createElement('my-element');\nskate.init(element);\n```\n\nTo take this example further, if we've extended an element:\n\n```js\nskate('my-element', {\n  extends: 'div'\n});\n```\n\nHow we call this function does not change:\n\n```js\nskate.create('my-element');\n```\n\nHowever, in native land this does change:\n\n```js\ndocument.createElement('div', 'my-element');\n```\n\nAnd in polyfill land, it's much different:\n\n```js\nvar element = document.createElement('div');\nelement.setAttribute('is', 'my-element');\nskate.init(element);\n```\n\nBoth the native and polyfilled examples above expose too many implementation details. It's much better to have one simple and consistent way to create an element.\n\n#### Alternatives\n\nIf you have access to the function / constructor returned from the `skate()` call, invoking that does the same exact thing as `skate.create()`:\n\n```js\nvar myElement;\nvar MyElement = skate('my-element', {});\n\n// Same thing:\nmyElement = skate.create('my-element');\nmyElement = MyElement();\nmyElement = new MyElement();\n```\n\n#### Setting Properties\n\nAll methods of constructing an element support passing properties.\n\n```js\nmyElement = skate.create('my-element', { prop: 'value' });\nmyElement = MyElement({ prop: 'value' });\nmyElement = new MyElement({ prop: 'value' });\n```\n\nPassing properties automatically assigns them to the element:\n\n```js\n// 'value'\nconsole.log(myElement.prop);\n```\n\n#### Why not just patch `document.createElement()`?\n\nSkate is designed to work with multiple versions of itself on the same page. If one version patches `document.createElement()` differently than another, then you have problems. Even if we did do this, how `document.createElement()` is called still depends on how the corresponding component has been registered, which is bad, especially when we can infer that information from the component definition.\n\n\n\n#### `emit (element, eventName, eventOptions = {})`\n\nEmits a `CustomEvent` on `element` that `bubbles` and is `cancelable` by default. This is useful for use in components that are children of a parent component and need to communicate changes to the parent.\n\n```js\nskate('x-tabs', {\n  events: {\n    selected: hideAllAndShowSelected\n  }\n});\n\nskate('x-tab', {\n  events: {\n    click: function () {\n      skate.emit(this, 'selected');\n    }\n  }\n});\n```\n\nIt's preferrable not to reach up the DOM hierarchy because that couples your logic to a specific DOM structure that the child has no control over. To decouple this so that your child can be used anywhere, simply trigger an event.\n\n#### Emitting Several Events at Once\n\nYou can emit more than one event at once by passing a space-separated string or an array as the `eventName` parameter:\n\n```js\nskate.emit(element, 'event1 event2');\nskate.emit(element, [ 'event1', 'event2' ]);\n```\n\n#### Return Value\n\nThe native `element.dispatchEvent()` method returns `false` if the event was cancelled. Since `skate.emit()` can trigger more then one event, a `Boolean` return value is ambiguous. Instead it returns an `Array` of the event names that were canceled.\n\n#### Preventing Bubbling or Canceling\n\nIf you don't want the event to bubble, or you don't want it to be cancelable, then you can specify those options in the `eventOptions` argument.\n\n```js\nskate.emit(element, 'event', {\n  bubbles: false,\n  cancelable: false\n});\n```\n\n\n\n### `emit (eventName, eventOptions = {})`\n\nSame as above except that it makes forwarding events simpler by returning a function that uses `this` as the `element` and calls `skate.emit(element, eventName, eventOptions)`. Using this form, the `x-tab` component's `click` handler from the example above could be simplified as:\n\n```js\nclick: skate.emit('selected')\n```\n\n\n\n### `event ()`\n\n[soon]\n\n\n\n### `init ()`\n\n[soon]\n\n\n\n### `noConflict ()`\n\nSame as what you'd come to expect from most libraries that offer a global namespace. It will restore the value of `window.skate` to the previous value and return the current `skate` object.\n\n```js\nvar currentSkate = skate.noConflict();\n```\n\n\n\n### `property (element, name, definition)`\n\nDefines the specified property `name` using `definition` on the `element`. The property definition is different than that normally specified to `Object.defineProperty()` and may contain the following options.\n\n#### `attr`\n\nWhether or not to link the property to an attribute. If `true`, then the property name will be converted from `camelCase` to `dash-case` and the result will be used as the linked attribute.\n\n```js\nattr: true\n```\n\nIf a `String`, then that will be used as the linked attribute exactly as it is specified.\n\n```js\nattr: 'my-attribute-name'\n```\n\nNo attribute is linked by default.\n\n#### `deps`\n\nA space-separated `String` or `Array` of property names that this property depends on. If any of these properties change, then this property's setter will be invoked.\n\n```js\ndeps: 'dependency1 dependency2'\n```\n\nOr:\n\n```js\ndeps: [ 'dependency1', 'dependency2' ]\n```\n\nYou can also specify dependencies on nested components by giving the dependency a dot-separated path.\n\n```js\ndeps: 'my.descendant.dependencyProperty'\n```\n\nIf you do this, there are a couple requirements that must be met:\n\n- The path (`my.descendant` in the above example) must be accessible from the element in which you're defining the property.\n- The name (`dependencyProperty` in the above example) must be defined as a property on `my.descendant` and notifying turned on.\n\n#### `get`\n\nThe custom getter for this property. If not specified, then the value is stored internally when the value is set and returned whenever it is retrieved. The element is passed as `this`.\n\nIf you want to make a property read-only, then specify `get` without `set`.\n\n#### `notify`\n\nWhether or not to emit an event when the property is set. Defaults to `true`.\n\nIf `true`, then a `skate.property` event is emitted:\n\n```js\nnotify: true\n```\n\nIf a `String`, then the value is used as the event name that is emitted.\n\n```js\nnotify: 'emit-this-instead'\n```\n\nYou may also specify any type of event spec that [`emit`](emit-element-eventname-eventoptions--) takes. This means you can specify a space-separated string or an array of event names.\n\n```js\nnotify: 'event1 event2',\nnotify: [ 'event1', 'event2' ]\n```\n\nThe event that gets emitted contains the following information in its `detail` property:\n\n- `e.detail.name` The property name.\n- `e.detail.newValue` The new value that was just set on the property.\n- `e.detail.oldValue` The previous value of the property.\n\n#### `set`\n\nThe custom setter for this property. The return value is ignored, so the logic in this method is responsible for setting the value however it needs to. The element is passed in as `this` and it receives two arguments: `newValue` and `oldValue`, in that order.\n\n```js\nset: function (newValue, oldValue) {\n  this.someOtherValue = oldValue + newValue;\n}\n```\n\n#### `type`\n\nResponsible for coercing the value before the setter is called. The return value of this function is what is passed as `newValue` into the setter.\n\n```js\ntype: Number\n```\n\nYou can use `type` in conjunction with `attr` to make a boolean attribute:\n\n```js\nattr: true,\ntype: Boolean\n```\n\nWhen the property is passed a truthy value, the attribute is added and void of a value. When passed a falsy value, the attribute is removed.\n\n#### `value`\n\nThe initial value for the property. It will be coerced and pass through the setter when initialised.\n\n```js\nvalue: 'initial value'\n```\n\nIf you specify a `Function` then it will be called and the return value used as the initial value.\n\n```js\nvalue: function () {\n  return 'initial value';\n}\n```\n\nThe element is *not* passed as `this` because property initialisation order is not guaranteed. If you need the element in order to compute the value, it's better to use `get` or `set` instead.\n\nIf you wanted to have a property linked to a boolean attribute and have it set on the element by default, all you'd have to do is:\n\n```js\nattr: true,\ntype: Boolean,\nvalue: true\n```\n\n\n\n### `property (element, definitions)`\n\nA way to define multiple property definitions to an `element` at once. The `definitions` argument is an object who's keys are the property names and values are the respective property definitions.\n\n\n\n### `ready (callback)`\n\nExecutes `callback` when all components are loaded and all elements are upgraded. This comes in handy inside a component when it requires descendants to be upgraded before it uses them.\n\nFor example, the following may not work because parents are upgraded before descendants in native custom elements:\n\n```js\nskate('x-parent', {\n  created: function () {\n    this.querySelector('x-child').sayHello();\n  }\n});\n\nskate('x-child', {\n  prototype: {\n    sayHello: function () {\n      console.log('hello');\n    }\n  }\n});\n```\n\nBut wrapping the call to `sayHello()` will:\n\n```js\nskate.ready(() => this.querySelector('x-child').sayHello());\n```\n\n\n\n### `type`\n\nContains the constants for each type of binding that Skate supports. They are:\n\n- `skate.type.ELEMENT` - Bind to a tag name.\n- `skate.type.ATTRIBUTE` - Bind to an attribute name.\n- `skate.type.CLASSNAME` - Bind to a class name.\n\n\n\n### `version`\n\nReturns the current version of Skate.\n\n\n\n### `watch (element, callback, options = {})`\n\nA convenient wrapper around Skate's internal `MutationObserver`. It allows you to watch an element for added or removed nodes.\n\n```js\nskate.watch(element, function (added, removed) {\n  console.log(added.length);\n  console.log(removed.length);\n});\n```\n\nIf you want to listen for changes to descendants, pass the `subtree` option:\n\n```js\nskate.watch(element, callback, { subtree: true });\n```\n\nCurrently, no other options besides `subtree` are supported.\n\n\n\n## Web Component Differences\n\nSkate implements the [Custom Element spec](http://w3c.github.io/webcomponents/spec/custom/) with a custom API but it does not polyfill the native methods. Since Skate is a custom element library, it does not polyfill [ShadowDOM](http://w3c.github.io/webcomponents/spec/shadow/) or [HTML Imports](http://w3c.github.io/webcomponents/spec/imports/).\n\nYou can do some pretty cool things with Skate that you can't do with Web Components. For example, you can write polyfills for existing elements:\n\n`<datalist>...</datalist>`:\n\n```js\nskate('datalist', {\n  created: polyfillDatalistElement\n});\n```\n\n`<input placeholder=\"\">`:\n\n```js\nskate('placeholder', {\n  extends: 'input',\n  type: skate.type.ATTRIBUTE,\n  created: polyfillInputPlaceholder\n});\n```\n\n`<input type=\"date\">`:\n\n```js\nskate('type', {\n  extends: 'input',\n  type: skate.type.ATTRIBUTE,\n  attributes: {\n    type: function (element, change) {\n      if (change.newValue === 'date') {\n        makeIntoDatepicker(element);\n      }\n    }\n  }\n});\n```\n\n`<link rel=\"import\" href=\"path/to/import.html\">` (HTML Imports):\n\n```js\nskate('rel', {\n  extends: 'link',\n  type: skate.type.ATTRIBUTE,\n  attributes: {\n    rel: function (element, change) {\n      if (change.newValue === 'import') {\n        makeIntoHtmlImport(element);\n      }\n    }\n  }\n});\n```\n\n\n\n## Transitioning Away from jQuery-style Plugins\n\nBecause Skate can also bind to attributes and classes, it offers a way to transition away from jQuery-style plugins to web components.\n\n```js\njQuery(function ($) {\n  $('.tabs').tabs();\n});\n```\n\nThere's several problems with this approach. First, you're running a selector against the document. This is unnecessary and can get slow in large DOMs even in the latest browsers. Second, it only gets executed on `DOMContentLoaded`. If you want to dynamically add some tabs to your document, then you've got to manually call that again once they've been added to the DOM.\n\nWith Skate, those problems vanish. No selectors are run and your tabs will automatically be initialised regardless of when they are put into the document.\n\nTo refactor that into a Skate component, all you need to do is:\n\n```js\nskate('tabs', {\n  type: skate.type.CLASSNAME\n  created: function () {\n    jQuery(this).tabs();\n  }\n});\n```\n\nPossibly the best part about this is that you don't need to touch any markup and only a minimal amount of JavaScript.\n\n\n\n## Native Support\n\nIf your component is bound via custom tags and your browser supports custom elements then Skate will use the native DOM implementation instead of using Mutation Observers which will have added performance benefits. This all happens underneath the hood and the API does not change.\n\n\n\n## Polyfills\n\nAs you may know, the only way to polyfill Mutation Observers is to use the deprecated DOM 3 Mutation Events. They were deprecated because if you insert 5k elements at once, you then trigger 5k handlers at once. Mutation Observers will batch that into a single callback.\n\nSkate mostly polyfills [Mutation Observers](https://developer.mozilla.org/en/docs/Web/API/MutationObserver), but only internally. It is not usable outside of Skate since it only polyfills what Skate needs to function. Its code is written to withstand an extreme number of incoming DOM elements. It's fast in Internet Explorer, not just modern browsers, and this is what sets it apart from other polyfills. It also ensures that mutation events are queued, rather than executed as they come in. Once queued, they are batched into a single callback.\n\n\n\n## Preventing FOUC\n\nAn element may not be initialised right away. To prevent FOUC, you can add the `unresolved` attribute to any web component element and then use that attribute to hide the element in your stylesheets.\n\n```html\n<style>\n  [unresolved] {\n    opacity: 0;\n  }\n</style>\n<my-element unresolved></my-element>\n```\n\nThe `unresolved` attribute will be removed after the `created()` callback is called and before the `attached()` callback is called.\n\nAdditionally, after removing the `unresolved` attribute, Skate will add the `resolved` attribute. This allows you to transition your styles:\n\n```css\n[resolved] {\n  opacity: 1;\n  transition: opacity .3s ease;\n}\n```\n\n\n## Ignoring Elements\n\nIf you have a DOM tree that you don't want Skate to polyfill then you can add the `data-skate-ignore` attribute. This is ideal for mitigating performance issues associated with older browsers and inspecting each element that is added to the document. Generally this is only an issue in Internet Explorer and dealing with hundreds of thousands of elements. If your browser natively supports Custom Elements then this attribute is ignored.\n\n```html\n<div data-skate-ignore>\n  <!-- Everything including the container will be ignored. -->\n</div>\n```\n\n\n\n## No Conflict\n\nSkate has a `noConflict()` method that we have come to expect from libraries that may come into conflict with the same name, or multiple versions of itself. It returns the new `skate` while restoring the global `skate` to the previous value.\n\n```js\nvar mySkate = skate.noConflict();\n```\n\n\n\n## Multiple Version Support\n\nOn top of offering a no-conflict mode, Skate plays well with multiple versions of itself on the same page. Prior to version `0.11` Skate did not share a registry or mutation observers. `0.11` and later share a registry and a mutation observer. This means that trying to register the same component in `0.11` and `0.12` would result in an error. Sharing a mutation observer ensures that we don't have more than main mutation observer on the page scanning incoming elements which helps with performance.\n\n\n\n## Contributing\n\nThe `.editorconfig`, `.jscs` and `.jshint` configs are all set up. If you can, enable these in your editor of choice.\n\n\n\n### Setup\n\nTo get a dev environment up and running, all you should need to do is run:\n\n```bash\nnpm install\n```\n\n\n### Testing\n\nTo run tests:\n\n```bash\nnpm test\n```\n\nIf you want to keep the Karma server alive to run them in your browser of choice:\n\n```bash\nnpm test -- --watch\n```\n\nTo run tests in a specific browser:\n\n```bash\nnpm test -- --browsers Chrome,Firefox\n```\n\n\n\n### Linting\n\nTo lint your files with `jscs` and `jshint`:\n\n```bash\nnpm run lint\n```\n\n\n\n### Distribution\n\nTo build the distribution all you have to do is run:\n\n```bash\nnpm run dist\n```\n\nThis will build `dist/skate.js` and `dist/skate.min.js`. Don't worry about doing this in a PR; it'll avoid conflicts.\n\nTo build the `lib` (ES5 + UMD) files:\n\n```bash\nnpm run lib\n```\n\n\n\n### Releasing\n\nTo release all you've got to do is run `npm release`. You can either specify the release `type`, or `tag`.\n\n```bash\nnpm run release -- --tag x.x.x\n```\n\nOr:\n\n```bash\nnpm run release -- --type minor\n```\n\n\n\n### Deploying\n\nTo deploy the documentation, run the following command from the branch or tag which you want to deploy:\n\n```bash\nnpm run deploy\n```\n\n\n\n## Who's Using It?\n\n<img alt=\"Atlassian\" src=\"http://www.atlassian.com/dms/wac/images/press/Atlassian-logos/logoAtlassianPNG.png\" width=\"200\">\n\n\n\n## Maintainers\n\n- [Trey Shugart](https://twitter.com/treshugart) (author), Atlassian\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/skatejs/skatejs/issues"
  },
  "homepage": "https://github.com/skatejs/skatejs#readme",
  "_id": "skatejs@0.13.2",
  "_shasum": "e82273f4e59bbf07fdc9f9b56dcea91472552dad",
  "_from": "skatejs/skatejs#a3249962713cf2dfb0001467b2d38d9c8a44c94c",
  "_resolved": "git://github.com/skatejs/skatejs.git#a3249962713cf2dfb0001467b2d38d9c8a44c94c"
}
